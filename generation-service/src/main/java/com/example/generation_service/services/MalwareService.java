package com.example.generation_service.services;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.MultipartBody;
import org.apache.commons.collections4.CollectionUtils;
import org.dmnvch.bytescale.model.JobResponseDto;
import org.dmnvch.bytescale.model.UploadFileResponseDto;
import org.dmnvch.bytescale.model.enumeration.MalwareCheckStatus;
import org.dmnvch.bytescale.service.ByteScaleService;
import org.springframework.stereotype.Service;

import java.util.Optional;

import static org.dmnvch.bytescale.model.enumeration.MalwareCheckStatus.*;

@RequiredArgsConstructor
@Service
@Slf4j
public class MalwareService {

    private static final int MAX_ATTEMPTS = 5;
    private static final long DELAY_MILLIS = 1500L;

    private final ByteScaleService byteScaleService;

    public MalwareCheckStatus isInfected(final MultipartBody.Part filePart, final String fileName) {
        try {
            return uploadAndCheckFile(filePart, fileName);
        } catch (Exception e) {
            log.error("Error occurred while processing file [{}]: {}", fileName, e.getMessage());
            return SKIPPED;
        }
    }

    private MalwareCheckStatus uploadAndCheckFile(final MultipartBody.Part filePart, final String fileName) {
        UploadFileResponseDto uploadResponse = byteScaleService.uploadFile(filePart).getData();
        if (uploadResponse != null) {
            if (CollectionUtils.isNotEmpty(uploadResponse.getErrors())) {
                final UploadFileResponseDto.ErrorDetails error = uploadResponse.getErrors().get(0).getError();
                log.warn("An error occurred during file [{}] upload. Error details: [{}]", fileName, error);
                return SKIPPED;
            }
            final String fullPath = Optional.of(uploadResponse)
                    .map(UploadFileResponseDto::getFiles)
                    .map(fileInfos -> fileInfos.get(0))
                    .map(UploadFileResponseDto.FileInfo::getFilePath)
                    .orElse(null);

            final String modifiedPath = Optional.ofNullable(fullPath)
                    .map(path -> path.substring(1))
                    .orElse(null);

           final MalwareCheckStatus status = checkFileForMalware(modifiedPath, fileName);
           byteScaleService.deleteFileUpload(fullPath);
           return status;
        }
        log.warn("An empty response returned when uploading file [{}].", fileName);
        return SKIPPED;
    }

    private MalwareCheckStatus checkFileForMalware(final String filePath, final String fileName) {
        if (filePath == null) {
            return SKIPPED;
        }
        final JobResponseDto jobResponse = getAntivirusCheckWithRetries(filePath);

        return Optional.ofNullable(jobResponse)
                .map(JobResponseDto::getSummary)
                .map(JobResponseDto.Summary::getResult)
                .flatMap(result -> result.getFiles().stream().findFirst())
                .map(fileInfo -> evaluateMalwareCheckStatus(fileInfo, fileName))
                .orElseGet(() -> {
                    log.warn("File [{}] could not get malware check status, skipping", fileName);
                    return SKIPPED;
                });
    }

    private JobResponseDto getAntivirusCheckWithRetries(final String filePath) {
        for (int attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
            JobResponseDto jobResponse = byteScaleService.getAntivirusCheck(filePath);
            if (jobResponse.getSummary().getResult() != null) {
                return jobResponse;
            }
            sleep();
        }
        log.warn("Max attempts reached for antivirus check on file path [{}]", filePath);
        return null;
    }

    private void sleep() {
        try {
            Thread.sleep(DELAY_MILLIS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Thread was interrupted during sleep between attempts", e);
        }
    }

    private MalwareCheckStatus evaluateMalwareCheckStatus(final JobResponseDto.Summary.Result.FileInfo fileInfo,
                                                          final String fileName) {
        return switch (fileInfo.getStatus()) {
            case HEALTHY -> HEALTHY;
            case SKIPPED -> {
                log.warn("File [{}] was skipped due to reason = [{}]", fileName, fileInfo.getSkippedReason());
                yield SKIPPED;
            }
            case INFECTED -> {
                log.warn("File [{}] is infected with viruses = [{}]", fileName, fileInfo.getViruses());
                yield INFECTED;
            }
        };
    }
}
